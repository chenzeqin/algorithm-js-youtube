# [leetcode 133. 克隆图](https://leetcode.cn/problems/clone-graph/description/)

给你无向 **[连通](https://baike.baidu.com/item/连通图/6460995?fr=aladdin)** 图中一个节点的引用，请你返回该图的 [**深拷贝**](https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin)（克隆）。

图中的每个节点都包含它的值 `val`（`int`） 和其邻居的列表（`list[Node]`）。

```javascript
class Node {
    public int val;
    public List<Node> neighbors;
}
```

## 解题思路

::: tip 核心思想
使用深度优先搜索（DFS）或广度优先搜索（BFS）遍历原图，同时使用 Map 记录已克隆的节点，避免重复克隆和循环引用。
:::

### 关键点

1. **避免重复克隆**：使用 `Map` 存储原节点到克隆节点的映射关系
2. **处理循环引用**：通过 `visited` Map 检查节点是否已被克隆，避免无限递归
3. **递归/迭代克隆邻居**：对于每个节点，需要克隆其所有邻居节点

### 算法步骤（DFS）

1. 如果节点为空，返回 `null`
2. 如果节点已在 Map 中，直接返回对应的克隆节点
3. 创建新节点，复制 `val` 值
4. 将原节点和克隆节点存入 Map
5. 递归克隆所有邻居节点，并添加到克隆节点的 `neighbors` 中

### 算法步骤（BFS）

1. 如果节点为空，返回 `null`
2. 创建队列，将原节点入队
3. 创建第一个克隆节点，存入 Map
4. 当队列不为空时：
   - 取出队首节点
   - 遍历其所有邻居
   - 如果邻居未被克隆，创建克隆节点并入队
   - 将克隆的邻居添加到克隆节点的 `neighbors` 中

## 代码实现

### 深度优先遍历

<<< @/09-图/9.5-克隆图/克隆图-深度优先遍历.js

### 广度优先遍历

<<< @/09-图/9.5-克隆图/克隆图-广度优先遍历.js

## 复杂度分析

- **时间复杂度**：`O(V + E)`，其中 V 是节点数，E 是边数。需要遍历图中的每个节点和每条边。
- **空间复杂度**：`O(V)`，主要是：
  - `visited` Map 存储所有节点：`O(V)`
  - DFS 递归栈或 BFS 队列：`O(V)`（最坏情况）

## 示例

```javascript
// 输入：adjList = [[2,4],[1,3],[2,4],[1,3]]
// 输出：[[2,4],[1,3],[2,4],[1,3]]
// 解释：
// 节点 1 的值是 1，它有两个邻居：节点 2 和 4 。
// 节点 2 的值是 2，它有两个邻居：节点 1 和 3 。
// 节点 3 的值是 3，它有两个邻居：节点 2 和 4 。
// 节点 4 的值是 4，它有两个邻居：节点 1 和 3 。
```

## 小结与易错点

- **必须使用 Map 记录已克隆节点**：否则会创建重复节点或陷入无限递归
- **DFS 和 BFS 都可以解决**：DFS 代码更简洁，BFS 适合处理深度很大的图
- **注意空节点处理**：输入可能为空，需要提前判断
