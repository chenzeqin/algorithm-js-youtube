# [leetcode 133. 克隆图](https://leetcode.cn/problems/clone-graph/description/)

## 解题思路

::: tip 核心思想
使用深度优先搜索（DFS）或广度优先搜索（BFS）遍历原图，同时使用 Map 记录已克隆的节点，避免重复克隆和循环引用。
:::

### 关键点

1. **避免重复克隆**：使用 `Map` 存储原节点到克隆节点的映射关系
2. **处理循环引用**：通过 `visited` Map 检查节点是否已被克隆，避免无限递归
3. **递归/迭代克隆邻居**：对于每个节点，需要克隆其所有邻居节点

### 算法步骤（DFS）

1. 如果节点为空，返回 `null`
2. 如果节点已在 Map 中，直接返回对应的克隆节点
3. 创建新节点，复制 `val` 值
4. 将原节点和克隆节点存入 Map
5. 递归克隆所有邻居节点，并添加到克隆节点的 `neighbors` 中

### 算法步骤（BFS）

1. 如果节点为空，返回 `null`
2. 创建队列，将原节点入队
3. 创建第一个克隆节点，存入 Map
4. 当队列不为空时：
   - 取出队首节点
   - 遍历其所有邻居
   - 如果邻居未被克隆，创建克隆节点并入队
   - 将克隆的邻居添加到克隆节点的 `neighbors` 中

## 代码实现

### 深度优先遍历

<<< @/09-图/9.5-克隆图/克隆图-深度优先遍历.js

### 广度优先遍历

<<< @/09-图/9.5-克隆图/克隆图-广度优先遍历.js

## 复杂度分析

- **时间复杂度**：`O(V + E)`，其中 V 是节点数，E 是边数。需要遍历图中的每个节点和每条边。
- **空间复杂度**：`O(V)`，主要是：
  - `visited` Map 存储所有节点：`O(V)`
  - DFS 递归栈或 BFS 队列：`O(V)`（最坏情况）

## 总结

- **必须使用 Map 记录已克隆节点**：否则会创建重复节点或陷入无限递归
- **DFS 和 BFS 都可以解决**：DFS 代码更简洁，BFS 适合处理深度很大的图
- **注意空节点处理**：输入可能为空，需要提前判断
